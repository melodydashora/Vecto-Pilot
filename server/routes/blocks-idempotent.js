// server/routes/blocks-idempotent.js
// Synchronous waterfall pipeline for autoscale compatibility
import { Router } from 'express';
import { db } from '../db/drizzle.js';
import { strategies, triad_jobs, snapshots, briefings } from '../../shared/schema.js';
import { eq, sql } from 'drizzle-orm';
import { idempotency } from '../middleware/idempotency.js';
import { ensureStrategyRow } from '../lib/strategy-utils.js';
import { runMinStrategy } from '../lib/providers/minstrategy.js';
import { runBriefing } from '../lib/providers/briefing.js';
import { runHolidayCheck } from '../lib/providers/holiday-checker.js';
import { consolidateStrategy } from '../lib/strategy-generator-parallel.js';
import { generateEnhancedSmartBlocks } from '../lib/enhanced-smart-blocks.js';

const router = Router();

// POST /api/blocks - Idempotent enqueue for triad processing
router.post('/api/blocks', idempotency({ ttlMs: 60000 }), async (req, res) => {
  const { snapshotId } = req.body || {};
  
  if (!snapshotId) {
    return res.status(400).json({ ok: false, error: 'snapshotId required' });
  }

  // Validate snapshotId format
  if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(snapshotId)) {
    return res.status(400).json({ ok: false, error: 'Invalid snapshotId format' });
  }

  try {
    // Check if strategy already exists
    const [existing] = await db
      .select()
      .from(strategies)
      .where(eq(strategies.snapshot_id, snapshotId))
      .limit(1);

    if (existing) {
      // Strategy exists, return success
      return res.status(200).json({ 
        ok: true, 
        status: existing.status,
        snapshotId 
      });
    }

    // Enqueue triad job (idempotent insert with unique constraint)
    const [job] = await db
      .insert(triad_jobs)
      .values({
        snapshot_id: snapshotId,
        kind: 'triad',
        status: 'queued'
      })
      .onConflictDoNothing()
      .returning();

    if (!job) {
      // Job already queued (conflict), return 202
      return res.status(202).json({ 
        ok: true, 
        status: 'queued', 
        snapshotId 
      });
    }

    // Job successfully queued - RUN FULL PIPELINE SYNCHRONOUSLY
    // This makes the app work in autoscale mode (no background worker needed)
    console.log(`[blocks] üöÄ Starting full pipeline for snapshot ${snapshotId}`);
    const pipelineStart = Date.now();
    
    // Ensure strategy row exists first
    await ensureStrategyRow(snapshotId);
    
    // STEP 1: Run providers in parallel and WAIT for all to complete (10-15s)
    console.log(`[blocks] üì° Step 1/4: Running providers (Holiday, MinStrategy, Briefing)...`);
    const providerStart = Date.now();
    await Promise.all([
      runHolidayCheck(snapshotId),    // FAST: writes strategies.holiday (1-2s)
      runMinStrategy(snapshotId),     // writes strategies.minstrategy (8-10s)
      runBriefing(snapshotId)         // writes briefings table (8-12s)
    ]);
    console.log(`[blocks] ‚úÖ Step 1/4 complete in ${Date.now() - providerStart}ms`);
    
    // STEP 2: Fetch data that providers wrote to database
    console.log(`[blocks] üìö Step 2/4: Fetching provider outputs...`);
    const [snapshot] = await db.select().from(snapshots).where(eq(snapshots.snapshot_id, snapshotId)).limit(1);
    const [strategy] = await db.select().from(strategies).where(eq(strategies.snapshot_id, snapshotId)).limit(1);
    const [briefing] = await db.select().from(briefings).where(eq(briefings.snapshot_id, snapshotId)).limit(1);
    
    if (!snapshot) {
      throw new Error('Snapshot not found after providers completed');
    }
    if (!strategy?.minstrategy) {
      throw new Error('MinStrategy not generated by provider');
    }
    if (!briefing) {
      throw new Error('Briefing not generated by provider');
    }
    console.log(`[blocks] ‚úÖ Step 2/4 complete - All provider outputs retrieved`);
    
    // STEP 3: Run consolidation (15-20s)
    console.log(`[blocks] üîÑ Step 3/4: Running consolidation (GPT-5)...`);
    const consolidationStart = Date.now();
    await consolidateStrategy({
      snapshotId,
      claudeStrategy: strategy.minstrategy,
      briefing: briefing,
      user: null,
      snapshot: snapshot,
      holiday: strategy.holiday
    });
    console.log(`[blocks] ‚úÖ Step 3/4 complete in ${Date.now() - consolidationStart}ms`);
    
    // STEP 4: Fetch consolidated strategy and generate smart blocks (10-15s)
    console.log(`[blocks] üéØ Step 4/4: Generating smart blocks...`);
    const blocksStart = Date.now();
    const [consolidatedStrategy] = await db.select().from(strategies).where(eq(strategies.snapshot_id, snapshotId)).limit(1);
    
    if (!consolidatedStrategy?.consolidated_strategy) {
      throw new Error('Consolidation failed to write consolidated_strategy');
    }
    
    await generateEnhancedSmartBlocks({
      snapshotId,
      consolidated: consolidatedStrategy.consolidated_strategy,
      briefing: briefing,
      snapshot: snapshot,
      user_id: null
    });
    console.log(`[blocks] ‚úÖ Step 4/4 complete in ${Date.now() - blocksStart}ms`);
    
    // PIPELINE COMPLETE - Return success
    const totalMs = Date.now() - pipelineStart;
    console.log(`[blocks] üéâ Full pipeline complete in ${totalMs}ms (~${Math.round(totalMs/1000)}s)`);
    
    return res.status(200).json({ 
      ok: true, 
      status: 'complete', 
      snapshotId,
      pipeline_ms: totalMs,
      message: 'Smart blocks ready'
    });
  } catch (error) {
    console.error('[blocks] Pipeline error:', error);
    
    // Log which step failed for debugging
    const errorMsg = error.message || 'Unknown error';
    if (errorMsg.includes('MinStrategy not generated')) {
      console.error('[blocks] ‚ùå Provider failure: MinStrategy did not complete');
    } else if (errorMsg.includes('Briefing not generated')) {
      console.error('[blocks] ‚ùå Provider failure: Briefing did not complete');
    } else if (errorMsg.includes('Consolidation failed')) {
      console.error('[blocks] ‚ùå Consolidation step failed');
    } else if (errorMsg.includes('Snapshot not found')) {
      console.error('[blocks] ‚ùå Snapshot missing from database');
    }
    
    return res.status(500).json({ 
      ok: false, 
      error: 'Strategy generation pipeline failed',
      details: process.env.NODE_ENV === 'development' ? errorMsg : undefined
    });
  }
});

export default router;
