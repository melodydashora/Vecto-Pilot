# Database Schema Reference

> **AUTO-GENERATED FILE** - Do not edit manually!
>
> Generated by `scripts/generate-schema-docs.js` from `shared/schema.js`
>
> Last generated: 2026-01-10T01:51:44.675Z

---

## Quick Reference

| Table | Export Name | Columns | Description |
|-------|-------------|---------|-------------|
| `users` | `users` | 4 | - |
| `snapshots` | `snapshots` | 1 | - |
| `strategies` | `strategies` | 3 | - |
| `briefings` | `briefings` | 2 | - |
| `rankings` | `rankings` | 1 | - |
| `ranking_candidates` | `ranking_candidates` | 2 | - |
| `actions` | `actions` | 1 | - |
| `venue_catalog` | `venue_catalog` | 2 | - |
| `venue_metrics` | `venue_metrics` | 6 | - |
| `block_jobs` | `block_jobs` | 5 | - |
| `triad_jobs` | `triad_jobs` | 2 | - |
| `http_idem` | `http_idem` | 3 | - |
| `places_cache` | `places_cache` | 2 | - |
| `venue_feedback` | `venue_feedback` | 3 | - |
| `strategy_feedback` | `strategy_feedback` | 3 | - |
| `app_feedback` | `app_feedback` | 2 | - |
| `travel_disruptions` | `travel_disruptions` | 12 | - |
| `llm_venue_suggestions` | `llm_venue_suggestions` | 1 | - |
| `agent_memory` | `agent_memory` | 5 | - |
| `assistant_memory` | `assistant_memory` | 5 | - |
| `eidolon_memory` | `eidolon_memory` | 5 | - |
| `cross_thread_memory` | `cross_thread_memory` | 5 | - |
| `eidolon_snapshots` | `eidolon_snapshots` | 7 | - |
| `venue_events` | `venue_events` | 4 | - |
| `discovered_events` | `discovered_events` | 8 | - |
| `traffic_zones` | `traffic_zones` | 11 | - |
| `agent_changes` | `agent_changes` | 5 | - |
| `connection_audit` | `connection_audit` | 1 | - |
| `coords_cache` | `coords_cache` | 11 | - |
| `platform_data` | `platform_data` | 14 | - |
| `countries` | `countries` | 0 | - |
| `markets` | `markets` | 4 | - |
| `us_market_cities` | `us_market_cities` | 7 | - |
| `market_intel` | `market_intel` | 6 | - |
| `driver_profiles` | `driver_profiles` | 2 | - |
| `driver_vehicles` | `driver_vehicles` | 2 | - |
| `auth_credentials` | `auth_credentials` | 2 | - |
| `verification_codes` | `verification_codes` | 2 | - |
| `vehicle_makes_cache` | `vehicle_makes_cache` | 4 | - |
| `vehicle_models_cache` | `vehicle_models_cache` | 6 | - |
| `market_intelligence` | `market_intelligence` | 19 | Market Intelligence Table Stores structured intell... |
| `user_intel_notes` | `user_intel_notes` | 2 | - |
| `coach_conversations` | `coach_conversations` | 2 | - |
| `coach_system_notes` | `coach_system_notes` | 8 | Market Intelligence Table Stores structured intell... |
| `intercepted_signals` | `intercepted_signals` | 1 | Market Intelligence Table Stores structured intell... |
| `driver_goals` | `driver_goals` | 2 | Market Intelligence Table Stores structured intell... |
| `driver_tasks` | `driver_tasks` | 2 | Market Intelligence Table Stores structured intell... |
| `safe_zones` | `safe_zones` | 2 | Market Intelligence Table Stores structured intell... |
| `staging_saturation` | `staging_saturation` | 3 | Market Intelligence Table Stores structured intell... |
| `news_deactivations` | `news_deactivations` | 2 | - |
| `zone_intelligence` | `zone_intelligence` | 17 | Market Intelligence Table Stores structured intell... |

---

## `users`

**Export:** `users`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `user_id` (PK) | UUID | YES | - | - |
| `device_id` | TEXT | NO | - | - |
| `session_id` | UUID | YES | - | - |
| `current_snapshot_id` | UUID | YES | - | - |

---

## `snapshots`

**Export:** `snapshots`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `snapshot_id` (PK) | UUID | YES | - | - |

---

## `strategies`

**Export:** `strategies`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `strategy_id` | UUID | YES | - | - |
| `snapshot_id` | UUID | NO | - | - |

---

## `briefings`

**Export:** `briefings`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `snapshot_id` | UUID | NO | - | - |

---

## `rankings`

**Export:** `rankings`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `ranking_id` (PK) | UUID | YES | - | - |

---

## `ranking_candidates`

**Export:** `ranking_candidates`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `ranking_id` | UUID | NO | - | - |

---

## `actions`

**Export:** `actions`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `action_id` (PK) | UUID | YES | - | - |

---

## `venue_catalog`

**Export:** `venue_catalog`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `venue_id` (PK) | UUID | YES | - | - |
| `place_id` | TEXT | YES | - | - |

---

## `venue_metrics`

**Export:** `venue_metrics`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `venue_id` (PK) | UUID | YES | - | venue_catalog.venue_id |
| `times_recommended` | INTEGER | NO | 0 | - |
| `times_chosen` | INTEGER | NO | 0 | - |
| `positive_feedback` | INTEGER | NO | 0 | - |
| `negative_feedback` | INTEGER | NO | 0 | - |
| `reliability_score` | DOUBLE PRECISION | NO | 0.5 | - |

---

## `block_jobs`

**Export:** `block_jobs`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `status` | TEXT | NO | - | - |
| `request_body` | JSONB | NO | - | - |
| `result` | JSONB | YES | - | - |
| `error` | TEXT | YES | - | - |

---

## `triad_jobs`

**Export:** `triad_jobs`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `snapshot_id` | UUID | NO | - | - |

---

## `http_idem`

**Export:** `http_idem`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `key` (PK) | TEXT | YES | - | - |
| `status` | INTEGER | NO | - | - |
| `body` | JSONB | NO | - | - |

---

## `places_cache`

**Export:** `places_cache`

*2026-01-10: D-013 Fix - Renamed `place_id` → `coords_key` for semantic accuracy. Column stores coordinate keys (lat_lng format like "33.123456_-96.123456"), not Google Place IDs.*

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `coords_key` (PK) | TEXT | YES | - | - |
| `formatted_hours` | JSONB | YES | - | - |
| `cached_at` | TIMESTAMPTZ | NO | - | - |
| `access_count` | INTEGER | NO | 0 | - |

---

## `venue_feedback`

**Export:** `venue_feedback`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | YES | - | - |
| `snapshot_id` | UUID | NO | - | - |

---

## `strategy_feedback`

**Export:** `strategy_feedback`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | YES | - | - |
| `snapshot_id` | UUID | NO | - | - |

---

## `app_feedback`

**Export:** `app_feedback`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `snapshot_id` | UUID | YES | - | - |

---

## `travel_disruptions`

**Export:** `travel_disruptions`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `country_code` | TEXT | NO | 'US' | - |
| `airport_code` | TEXT | NO | - | - |
| `airport_name` | TEXT | YES | - | - |
| `delay_minutes` | INTEGER | YES | 0 | - |
| `ground_stops` | JSONB | YES | [] | - |
| `ground_delay_programs` | JSONB | YES | [] | - |
| `closure_status` | TEXT | YES | 'open' | - |
| `delay_reason` | TEXT | YES | - | - |
| `ai_summary` | TEXT | YES | - | - |
| `impact_level` | TEXT | YES | 'none' | - |
| `data_source` | TEXT | NO | 'FAA' | - |

---

## `llm_venue_suggestions`

**Export:** `llm_venue_suggestions`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `suggestion_id` (PK) | UUID | YES | - | - |

---

## `agent_memory`

**Export:** `agent_memory`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `scope` | TEXT | NO | - | - |
| `key` | TEXT | NO | - | - |
| `user_id` | UUID | YES | - | - |
| `content` | TEXT | NO | - | - |

---

## `assistant_memory`

**Export:** `assistant_memory`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `scope` | TEXT | NO | - | - |
| `key` | TEXT | NO | - | - |
| `user_id` | UUID | YES | - | - |
| `content` | TEXT | NO | - | - |

---

## `eidolon_memory`

**Export:** `eidolon_memory`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `scope` | TEXT | NO | - | - |
| `key` | TEXT | NO | - | - |
| `user_id` | UUID | YES | - | - |
| `content` | TEXT | NO | - | - |

---

## `cross_thread_memory`

**Export:** `cross_thread_memory`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `scope` | TEXT | NO | - | - |
| `key` | TEXT | NO | - | - |
| `user_id` | UUID | YES | - | - |
| `content` | TEXT | NO | - | - |

---

## `eidolon_snapshots`

**Export:** `eidolon_snapshots`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `snapshot_id` | UUID | YES | - | - |
| `user_id` | UUID | YES | - | - |
| `session_id` | TEXT | YES | - | - |
| `scope` | TEXT | NO | - | - |
| `state` | JSONB | NO | - | - |
| `metadata` | JSONB | YES | - | - |

---

## `venue_events`

**Export:** `venue_events`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `venue_id` | UUID | YES | - | - |
| `place_id` | TEXT | YES | - | - |
| `title` | TEXT | NO | - | - |

---

## `discovered_events`

**Export:** `discovered_events`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `title` | TEXT | NO | - | - |
| `venue_name` | TEXT | YES | - | - |
| `address` | TEXT | YES | - | - |
| `city` | TEXT | NO | - | - |
| `state` | TEXT | NO | - | - |
| `zip` | TEXT | YES | - | - |
| `venue_id` | UUID | YES | - | - |

---

## `traffic_zones`

**Export:** `traffic_zones`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `lat` | DOUBLE PRECISION | NO | - | - |
| `lng` | DOUBLE PRECISION | NO | - | - |
| `city` | TEXT | YES | - | - |
| `state` | TEXT | YES | - | - |
| `traffic_density` | INTEGER | YES | - | - |
| `density_level` | TEXT | YES | - | - |
| `congestion_areas` | JSONB | YES | - | - |
| `high_demand_zones` | JSONB | YES | - | - |
| `driver_advice` | TEXT | YES | - | - |
| `sources` | JSONB | YES | - | - |

---

## `agent_changes`

**Export:** `agent_changes`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `change_type` | TEXT | NO | - | - |
| `description` | TEXT | NO | - | - |
| `file_path` | TEXT | YES | - | - |
| `details` | JSONB | YES | - | - |

---

## `connection_audit`

**Export:** `connection_audit`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |

---

## `coords_cache`

**Export:** `coords_cache`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `coord_key` | TEXT | NO | - | - |
| `lat` | DOUBLE PRECISION | NO | - | - |
| `lng` | DOUBLE PRECISION | NO | - | - |
| `formatted_address` | TEXT | NO | - | - |
| `city` | TEXT | NO | - | - |
| `state` | TEXT | NO | - | - |
| `country` | TEXT | NO | - | - |
| `timezone` | TEXT | NO | - | - |
| `closest_airport` | TEXT | YES | - | - |
| `closest_airport_code` | TEXT | YES | - | - |

---

## `platform_data`

**Export:** `platform_data`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `platform` | TEXT | NO | - | - |
| `country` | TEXT | NO | - | - |
| `country_code` | TEXT | YES | - | - |
| `region` | TEXT | YES | - | - |
| `city` | TEXT | NO | - | - |
| `market` | TEXT | YES | - | - |
| `market_anchor` | TEXT | YES | - | - |
| `region_type` | TEXT | YES | - | - |
| `timezone` | TEXT | YES | - | - |
| `coord_boundary` | JSONB | YES | - | - |
| `center_lat` | DOUBLE PRECISION | YES | - | - |
| `center_lng` | DOUBLE PRECISION | YES | - | - |
| `is_active` | BOOLEAN | NO | true | - |

---

## `countries`

**Export:** `countries`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|

---

## `markets`

**Export:** `markets`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `market_slug` (PK) | TEXT | YES | - | - |
| `market_name` | TEXT | NO | - | - |
| `primary_city` | TEXT | NO | - | - |
| `state` | TEXT | NO | - | - |

---

## `us_market_cities`

**Export:** `us_market_cities`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `state` | TEXT | NO | - | - |
| `state_abbr` | TEXT | YES | - | - |
| `city` | TEXT | NO | - | - |
| `market_name` | TEXT | NO | - | - |
| `region_type` | TEXT | NO | 'Satellite' | - |
| `source_ref` | TEXT | YES | - | - |

---

## `market_intel`

**Export:** `market_intel`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `market_name` | TEXT | NO | - | - |
| `intel_type` | TEXT | NO | - | - |
| `title` | TEXT | NO | - | - |
| `content` | TEXT | NO | - | - |
| `insight_data` | JSONB | YES | - | - |

---

## `driver_profiles`

**Export:** `driver_profiles`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `driver_vehicles`

**Export:** `driver_vehicles`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `driver_profile_id` | UUID | NO | - | - |

---

## `auth_credentials`

**Export:** `auth_credentials`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `verification_codes`

**Export:** `verification_codes`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | YES | - | - |

---

## `vehicle_makes_cache`

**Export:** `vehicle_makes_cache`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `make_id` | INTEGER | NO | - | - |
| `make_name` | TEXT | NO | - | - |
| `is_common` | BOOLEAN | YES | false | - |

---

## `vehicle_models_cache`

**Export:** `vehicle_models_cache`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `make_id` | INTEGER | NO | - | - |
| `make_name` | TEXT | NO | - | - |
| `model_id` | INTEGER | NO | - | - |
| `model_name` | TEXT | NO | - | - |
| `model_year` | INTEGER | YES | - | - |

---

## `market_intelligence`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness

**Export:** `market_intelligence`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `market` | TEXT | NO | - | - |
| `market_slug` | TEXT | NO | - | - |
| `platform` | TEXT | NO | 'both' | - |
| `intel_type` | TEXT | NO | - | - |
| `intel_subtype` | TEXT | YES | - | - |
| `title` | TEXT | NO | - | - |
| `summary` | TEXT | YES | - | - |
| `content` | TEXT | NO | - | - |
| `neighborhoods` | JSONB | YES | - | - |
| `boundaries` | JSONB | YES | - | - |
| `time_context` | JSONB | YES | - | - |
| `tags` | JSONB | YES | sql`'[]'` | - |
| `priority` | INTEGER | YES | 50 | - |
| `source` | TEXT | NO | 'research' | - |
| `source_file` | TEXT | YES | - | - |
| `source_section` | TEXT | YES | - | - |
| `confidence` | INTEGER | YES | 80 | - |
| `version` | INTEGER | YES | 1 | - |

---

## `user_intel_notes`

**Export:** `user_intel_notes`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | YES | - | - |

---

## `coach_conversations`

**Export:** `coach_conversations`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `coach_system_notes`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features

**Export:** `coach_system_notes`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `note_type` | TEXT | NO | - | - |
| `category` | TEXT | NO | - | - |
| `priority` | INTEGER | YES | 50 | - |
| `title` | TEXT | NO | - | - |
| `description` | TEXT | NO | - | - |
| `user_quote` | TEXT | YES | - | - |
| `triggering_user_id` | UUID | YES | - | - |

---

## `intercepted_signals`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth.

**Export:** `intercepted_signals`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |

---

## `driver_goals`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth. export const intercepted_signals = pgTable("intercepted_signals", { id: uuid("id").primaryKey().defaultRandom(), // Device identification (PRIMARY identifier for headless clients) device_id: varchar("device_id", { length: 255 }).notNull(), // User association (OPTIONAL - NO FK constraint!) // Nullable because Siri Shortcuts run without authenticated sessions. // Can be linked later if user logs in on same device. user_id: uuid("user_id"), // Intentionally NO .references() - headless ingestion // Raw input from OCR raw_text: text("raw_text").notNull(), // Parsed offer data // Schema: { price, miles, time, pickup, dropoff, platform, surge, per_mile } parsed_data: jsonb("parsed_data"), // AI decision decision: text("decision").notNull(), // 'ACCEPT' | 'REJECT' decision_reasoning: text("decision_reasoning"), // AI explanation confidence_score: doublePrecision("confidence_score"), // 0.0 - 1.0 // User override (if driver disagreed with AI) user_override: text("user_override"), // null | 'ACCEPT' | 'REJECT' // Source tracking source: varchar("source", { length: 50 }).notNull().default('siri_shortcut'), // 'siri_shortcut' | 'android_automation' | 'manual' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxDeviceId: sql`create index if not exists idx_intercepted_signals_device_id on ${table} (device_id)`, idxUserId: sql`create index if not exists idx_intercepted_signals_user_id on ${table} (user_id) where user_id is not null`, idxCreatedAt: sql`create index if not exists idx_intercepted_signals_created on ${table} (device_id, created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // DISPATCH PRIMITIVES (2026-01-06) // Schema additions for "Where do I go to make $500 today and still get home?" // These tables enable goal-aware, safety-bounded dispatch recommendations. // ═══════════════════════════════════════════════════════════════════════════ Driver Goals Table (P2-A) Tracks earning goals, trip targets, and time constraints. Enables queries like "I want to make $500 by 6pm".

**Export:** `driver_goals`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `driver_tasks`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth. export const intercepted_signals = pgTable("intercepted_signals", { id: uuid("id").primaryKey().defaultRandom(), // Device identification (PRIMARY identifier for headless clients) device_id: varchar("device_id", { length: 255 }).notNull(), // User association (OPTIONAL - NO FK constraint!) // Nullable because Siri Shortcuts run without authenticated sessions. // Can be linked later if user logs in on same device. user_id: uuid("user_id"), // Intentionally NO .references() - headless ingestion // Raw input from OCR raw_text: text("raw_text").notNull(), // Parsed offer data // Schema: { price, miles, time, pickup, dropoff, platform, surge, per_mile } parsed_data: jsonb("parsed_data"), // AI decision decision: text("decision").notNull(), // 'ACCEPT' | 'REJECT' decision_reasoning: text("decision_reasoning"), // AI explanation confidence_score: doublePrecision("confidence_score"), // 0.0 - 1.0 // User override (if driver disagreed with AI) user_override: text("user_override"), // null | 'ACCEPT' | 'REJECT' // Source tracking source: varchar("source", { length: 50 }).notNull().default('siri_shortcut'), // 'siri_shortcut' | 'android_automation' | 'manual' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxDeviceId: sql`create index if not exists idx_intercepted_signals_device_id on ${table} (device_id)`, idxUserId: sql`create index if not exists idx_intercepted_signals_user_id on ${table} (user_id) where user_id is not null`, idxCreatedAt: sql`create index if not exists idx_intercepted_signals_created on ${table} (device_id, created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // DISPATCH PRIMITIVES (2026-01-06) // Schema additions for "Where do I go to make $500 today and still get home?" // These tables enable goal-aware, safety-bounded dispatch recommendations. // ═══════════════════════════════════════════════════════════════════════════ Driver Goals Table (P2-A) Tracks earning goals, trip targets, and time constraints. Enables queries like "I want to make $500 by 6pm". export const driver_goals = pgTable("driver_goals", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Goal definition goal_type: text("goal_type").notNull(), // 'earnings' | 'trips' | 'hours' | 'custom' target_amount: doublePrecision("target_amount"), // e.g., 500 for $500, or 10 for 10 trips target_unit: text("target_unit").default('dollars'), // 'dollars' | 'trips' | 'hours' // Time constraints deadline: timestamp("deadline", { withTimezone: true }), // When goal must be achieved by min_hourly_rate: doublePrecision("min_hourly_rate"), // e.g., 35.00 for $35/hr minimum // Priority urgency: text("urgency").default('normal'), // 'low' | 'normal' | 'high' | 'critical' // Status is_active: boolean("is_active").default(true), progress_amount: doublePrecision("progress_amount").default(0), // Current progress completed_at: timestamp("completed_at", { withTimezone: true }), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_goals_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_driver_goals_active on ${table} (user_id, is_active) where is_active = true`, })); Driver Tasks Table (P2-B) Hard stops and time constraints (car wash, pickup kids, appointments). Enables "return-home plan" that respects non-driving obligations.

**Export:** `driver_tasks`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `safe_zones`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth. export const intercepted_signals = pgTable("intercepted_signals", { id: uuid("id").primaryKey().defaultRandom(), // Device identification (PRIMARY identifier for headless clients) device_id: varchar("device_id", { length: 255 }).notNull(), // User association (OPTIONAL - NO FK constraint!) // Nullable because Siri Shortcuts run without authenticated sessions. // Can be linked later if user logs in on same device. user_id: uuid("user_id"), // Intentionally NO .references() - headless ingestion // Raw input from OCR raw_text: text("raw_text").notNull(), // Parsed offer data // Schema: { price, miles, time, pickup, dropoff, platform, surge, per_mile } parsed_data: jsonb("parsed_data"), // AI decision decision: text("decision").notNull(), // 'ACCEPT' | 'REJECT' decision_reasoning: text("decision_reasoning"), // AI explanation confidence_score: doublePrecision("confidence_score"), // 0.0 - 1.0 // User override (if driver disagreed with AI) user_override: text("user_override"), // null | 'ACCEPT' | 'REJECT' // Source tracking source: varchar("source", { length: 50 }).notNull().default('siri_shortcut'), // 'siri_shortcut' | 'android_automation' | 'manual' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxDeviceId: sql`create index if not exists idx_intercepted_signals_device_id on ${table} (device_id)`, idxUserId: sql`create index if not exists idx_intercepted_signals_user_id on ${table} (user_id) where user_id is not null`, idxCreatedAt: sql`create index if not exists idx_intercepted_signals_created on ${table} (device_id, created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // DISPATCH PRIMITIVES (2026-01-06) // Schema additions for "Where do I go to make $500 today and still get home?" // These tables enable goal-aware, safety-bounded dispatch recommendations. // ═══════════════════════════════════════════════════════════════════════════ Driver Goals Table (P2-A) Tracks earning goals, trip targets, and time constraints. Enables queries like "I want to make $500 by 6pm". export const driver_goals = pgTable("driver_goals", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Goal definition goal_type: text("goal_type").notNull(), // 'earnings' | 'trips' | 'hours' | 'custom' target_amount: doublePrecision("target_amount"), // e.g., 500 for $500, or 10 for 10 trips target_unit: text("target_unit").default('dollars'), // 'dollars' | 'trips' | 'hours' // Time constraints deadline: timestamp("deadline", { withTimezone: true }), // When goal must be achieved by min_hourly_rate: doublePrecision("min_hourly_rate"), // e.g., 35.00 for $35/hr minimum // Priority urgency: text("urgency").default('normal'), // 'low' | 'normal' | 'high' | 'critical' // Status is_active: boolean("is_active").default(true), progress_amount: doublePrecision("progress_amount").default(0), // Current progress completed_at: timestamp("completed_at", { withTimezone: true }), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_goals_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_driver_goals_active on ${table} (user_id, is_active) where is_active = true`, })); Driver Tasks Table (P2-B) Hard stops and time constraints (car wash, pickup kids, appointments). Enables "return-home plan" that respects non-driving obligations. export const driver_tasks = pgTable("driver_tasks", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Task definition title: text("title").notNull(), // e.g., "Car wash appointment" description: text("description"), // Time constraints due_at: timestamp("due_at", { withTimezone: true }), // When task must be done by duration_minutes: integer("duration_minutes"), // How long task takes // Location (optional - some tasks are location-bound) location: text("location"), // Address or place description place_id: text("place_id"), // Google Place ID if available lat: doublePrecision("lat"), lng: doublePrecision("lng"), // Priority is_hard_stop: boolean("is_hard_stop").default(false), // Must stop driving for this priority: integer("priority").default(50), // 1-100 // Status is_complete: boolean("is_complete").default(false), completed_at: timestamp("completed_at", { withTimezone: true }), // Recurrence (optional) recurrence: text("recurrence"), // 'daily' | 'weekly' | 'weekdays' | null // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_tasks_user_id on ${table} (user_id)`, idxDueAt: sql`create index if not exists idx_driver_tasks_due_at on ${table} (user_id, due_at) where is_complete = false`, idxHardStop: sql`create index if not exists idx_driver_tasks_hard_stop on ${table} (user_id, due_at) where is_hard_stop = true and is_complete = false`, })); Safe Zones Table (P2-C) Geofence definitions for safety boundaries. Enables "stay inside safe boundary unless goal demands otherwise".

**Export:** `safe_zones`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `staging_saturation`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth. export const intercepted_signals = pgTable("intercepted_signals", { id: uuid("id").primaryKey().defaultRandom(), // Device identification (PRIMARY identifier for headless clients) device_id: varchar("device_id", { length: 255 }).notNull(), // User association (OPTIONAL - NO FK constraint!) // Nullable because Siri Shortcuts run without authenticated sessions. // Can be linked later if user logs in on same device. user_id: uuid("user_id"), // Intentionally NO .references() - headless ingestion // Raw input from OCR raw_text: text("raw_text").notNull(), // Parsed offer data // Schema: { price, miles, time, pickup, dropoff, platform, surge, per_mile } parsed_data: jsonb("parsed_data"), // AI decision decision: text("decision").notNull(), // 'ACCEPT' | 'REJECT' decision_reasoning: text("decision_reasoning"), // AI explanation confidence_score: doublePrecision("confidence_score"), // 0.0 - 1.0 // User override (if driver disagreed with AI) user_override: text("user_override"), // null | 'ACCEPT' | 'REJECT' // Source tracking source: varchar("source", { length: 50 }).notNull().default('siri_shortcut'), // 'siri_shortcut' | 'android_automation' | 'manual' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxDeviceId: sql`create index if not exists idx_intercepted_signals_device_id on ${table} (device_id)`, idxUserId: sql`create index if not exists idx_intercepted_signals_user_id on ${table} (user_id) where user_id is not null`, idxCreatedAt: sql`create index if not exists idx_intercepted_signals_created on ${table} (device_id, created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // DISPATCH PRIMITIVES (2026-01-06) // Schema additions for "Where do I go to make $500 today and still get home?" // These tables enable goal-aware, safety-bounded dispatch recommendations. // ═══════════════════════════════════════════════════════════════════════════ Driver Goals Table (P2-A) Tracks earning goals, trip targets, and time constraints. Enables queries like "I want to make $500 by 6pm". export const driver_goals = pgTable("driver_goals", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Goal definition goal_type: text("goal_type").notNull(), // 'earnings' | 'trips' | 'hours' | 'custom' target_amount: doublePrecision("target_amount"), // e.g., 500 for $500, or 10 for 10 trips target_unit: text("target_unit").default('dollars'), // 'dollars' | 'trips' | 'hours' // Time constraints deadline: timestamp("deadline", { withTimezone: true }), // When goal must be achieved by min_hourly_rate: doublePrecision("min_hourly_rate"), // e.g., 35.00 for $35/hr minimum // Priority urgency: text("urgency").default('normal'), // 'low' | 'normal' | 'high' | 'critical' // Status is_active: boolean("is_active").default(true), progress_amount: doublePrecision("progress_amount").default(0), // Current progress completed_at: timestamp("completed_at", { withTimezone: true }), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_goals_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_driver_goals_active on ${table} (user_id, is_active) where is_active = true`, })); Driver Tasks Table (P2-B) Hard stops and time constraints (car wash, pickup kids, appointments). Enables "return-home plan" that respects non-driving obligations. export const driver_tasks = pgTable("driver_tasks", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Task definition title: text("title").notNull(), // e.g., "Car wash appointment" description: text("description"), // Time constraints due_at: timestamp("due_at", { withTimezone: true }), // When task must be done by duration_minutes: integer("duration_minutes"), // How long task takes // Location (optional - some tasks are location-bound) location: text("location"), // Address or place description place_id: text("place_id"), // Google Place ID if available lat: doublePrecision("lat"), lng: doublePrecision("lng"), // Priority is_hard_stop: boolean("is_hard_stop").default(false), // Must stop driving for this priority: integer("priority").default(50), // 1-100 // Status is_complete: boolean("is_complete").default(false), completed_at: timestamp("completed_at", { withTimezone: true }), // Recurrence (optional) recurrence: text("recurrence"), // 'daily' | 'weekly' | 'weekdays' | null // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_tasks_user_id on ${table} (user_id)`, idxDueAt: sql`create index if not exists idx_driver_tasks_due_at on ${table} (user_id, due_at) where is_complete = false`, idxHardStop: sql`create index if not exists idx_driver_tasks_hard_stop on ${table} (user_id, due_at) where is_hard_stop = true and is_complete = false`, })); Safe Zones Table (P2-C) Geofence definitions for safety boundaries. Enables "stay inside safe boundary unless goal demands otherwise". export const safe_zones = pgTable("safe_zones", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Zone identity zone_name: text("zone_name").notNull(), // e.g., "Home area", "Downtown avoid" zone_type: text("zone_type").notNull(), // 'safe' | 'avoid' | 'prefer' // Geometry (one of these should be set) geometry: text("geometry"), // GeoJSON polygon center_lat: doublePrecision("center_lat"), center_lng: doublePrecision("center_lng"), radius_miles: doublePrecision("radius_miles"), // Circular zone radius neighborhoods: text("neighborhoods"), // Comma-separated neighborhood names (alternative to geometry) // Risk assessment risk_level: integer("risk_level"), // 1-5 (1=safest, 5=most risky) risk_notes: text("risk_notes"), // Why this zone has certain risk level // Usage flags is_active: boolean("is_active").default(true), applies_at_night: boolean("applies_at_night").default(true), // Apply after 9pm applies_at_day: boolean("applies_at_day").default(true), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_safe_zones_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_safe_zones_active on ${table} (user_id, is_active) where is_active = true`, idxType: sql`create index if not exists idx_safe_zones_type on ${table} (user_id, zone_type)`, })); Staging Saturation Tracker (P2-D) Tracks staging location suggestions to prevent overcrowding. When many drivers ask for recommendations, we diversify suggestions to avoid sending everyone to the same hotspot. Uses H3 cells (resolution 8 = ~0.5km) for location grouping.

**Export:** `staging_saturation`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `h3_cell` | TEXT | NO | - | - |
| `venue_name` | TEXT | YES | - | - |

---

## `news_deactivations`

**Export:** `news_deactivations`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `user_id` | UUID | NO | - | - |

---

## `zone_intelligence`

Market Intelligence Table Stores structured intelligence data derived from research documents and AI analysis. Supports multiple intelligence types per market with versioning and attribution. Intelligence Types: - regulatory: Legal/regulatory context (Prop 22, TLC rules, etc.) - strategy: Operational doctrine and optimization tactics - zone: Geographic areas (honey_hole, danger_zone, dead_zone, safe_corridor) - timing: Time-based patterns (rush hours, seasonality, surge patterns) - airport: Airport-specific strategies and queue info - safety: Safety advisories and risk areas - algorithm: Platform algorithm mechanics (Advantage Mode, etc.) - vehicle: Vehicle type recommendations (XL, Comfort, etc.) - general: General tips and advice Zone Sub-types (when intel_type = 'zone'): - honey_hole: High-demand, profitable areas - danger_zone: Safety risk areas (crime, carjacking) - dead_zone: Low demand, unprofitable areas - safe_corridor: Recommended safe operating areas - caution_zone: Areas requiring situational awareness export const market_intelligence = pgTable("market_intelligence", { id: uuid("id").primaryKey().defaultRandom(), // Market identification (matches platform_data.market format) market: text("market").notNull(), // e.g., 'Los Angeles', 'New York City', 'Chicago' market_slug: text("market_slug").notNull(), // e.g., 'los-angeles', 'new-york-city', 'chicago' // Platform scope platform: text("platform").notNull().default('both'), // 'uber', 'lyft', 'both' // Intelligence classification intel_type: text("intel_type").notNull(), // 'regulatory', 'strategy', 'zone', 'timing', 'airport', 'safety', 'algorithm', 'vehicle', 'general' intel_subtype: text("intel_subtype"), // For zones: 'honey_hole', 'danger_zone', 'dead_zone', 'safe_corridor', 'caution_zone' // Content title: text("title").notNull(), // Short descriptive title summary: text("summary"), // Brief 1-2 sentence summary content: text("content").notNull(), // Full intelligence content (markdown supported) // Geographic context (for zone-type intelligence) neighborhoods: jsonb("neighborhoods"), // Array of neighborhood names boundaries: jsonb("boundaries"), // Geographic boundaries (lat/lng polygon or description) // Temporal context (for timing-type intelligence) time_context: jsonb("time_context"), // { days: ['mon','tue'...], hours: [8,9,10...], seasonal: 'high_season' } // Categorization tags: jsonb("tags").default(sql`'[]'`), // Array of searchable tags priority: integer("priority").default(50), // 1-100, higher = more important // Attribution and quality source: text("source").notNull().default('research'), // 'research', 'ai_coach', 'driver_report', 'official' source_file: text("source_file"), // Original file path (e.g., 'platform-data/uber/research-findings/gemini-findings.txt') source_section: text("source_section"), // Section reference in source (e.g., '3. Market Analysis: Los Angeles') confidence: integer("confidence").default(80), // 1-100, how reliable is this info // Versioning version: integer("version").default(1), effective_date: timestamp("effective_date", { withTimezone: true }), // When this intel became valid expiry_date: timestamp("expiry_date", { withTimezone: true }), // When this intel may be outdated // Status is_active: boolean("is_active").default(true), is_verified: boolean("is_verified").default(false), // Has been human-verified // AI Coach integration coach_can_cite: boolean("coach_can_cite").default(true), // AI Coach can reference this coach_priority: integer("coach_priority").default(50), // Priority for AI Coach retrieval // Audit created_by: text("created_by").notNull().default('system'), // 'system', 'ai_coach', user_id updated_by: text("updated_by"), created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxMarket: sql`create index if not exists idx_market_intelligence_market on ${table} (market)`, idxMarketSlug: sql`create index if not exists idx_market_intelligence_market_slug on ${table} (market_slug)`, idxPlatform: sql`create index if not exists idx_market_intelligence_platform on ${table} (platform)`, idxIntelType: sql`create index if not exists idx_market_intelligence_intel_type on ${table} (intel_type)`, idxIntelSubtype: sql`create index if not exists idx_market_intelligence_intel_subtype on ${table} (intel_subtype)`, idxActive: sql`create index if not exists idx_market_intelligence_active on ${table} (is_active)`, idxSource: sql`create index if not exists idx_market_intelligence_source on ${table} (source)`, idxCoachCite: sql`create index if not exists idx_market_intelligence_coach_cite on ${table} (coach_can_cite, coach_priority)`, // Composite for common queries idxMarketTypeActive: sql`create index if not exists idx_market_intelligence_market_type_active on ${table} (market_slug, intel_type, is_active)`, // GIN index for tags search idxTags: sql`create index if not exists idx_market_intelligence_tags on ${table} using gin (tags)`, })); // ═══════════════════════════════════════════════════════════════════════════ // USER INTEL NOTES: Coach-generated notes from user interactions // ═══════════════════════════════════════════════════════════════════════════ Stores notes generated by the AI Coach during user interactions. These notes capture insights, preferences, and learned patterns that help the coach provide more personalized advice over time. Note Types: - preference: User driving preferences (times, areas, vehicle type) - insight: Learned insights about user's market/strategy - tip: Personalized tips discovered during conversation - feedback: User feedback on coach advice effectiveness - pattern: Detected patterns in user behavior/questions - market_update: Market-specific updates relevant to user // 2026-01-05: Changed onDelete from 'cascade' to 'set null' - preserve coach's learnings export const user_intel_notes = pgTable("user_intel_notes", { id: uuid("id").primaryKey().defaultRandom(), // User identification user_id: uuid("user_id").references(() => users.user_id, { onDelete: 'set null' }), snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Note classification note_type: text("note_type").notNull().default('insight'), // 'preference', 'insight', 'tip', 'feedback', 'pattern', 'market_update' category: text("category"), // Optional grouping: 'timing', 'location', 'strategy', 'vehicle', 'earnings', 'safety' // Content title: text("title"), // Short title for the note content: text("content").notNull(), // The actual note content context: text("context"), // What prompted this note (conversation excerpt) // Market context (optional - for market-specific notes) market_slug: text("market_slug"), // Link to market if applicable neighborhoods: jsonb("neighborhoods"), // Specific neighborhoods mentioned // Relevance scoring importance: integer("importance").default(50), // 1-100, how important for future advice confidence: integer("confidence").default(80), // 1-100, how confident coach is in this note times_referenced: integer("times_referenced").default(0), // How often this note has been used // Temporal validity valid_from: timestamp("valid_from", { withTimezone: true }).defaultNow(), valid_until: timestamp("valid_until", { withTimezone: true }), // NULL = indefinitely valid // Status is_active: boolean("is_active").default(true), is_pinned: boolean("is_pinned").default(false), // User/coach can pin important notes // Source tracking source_message_id: text("source_message_id"), // Chat message ID that generated this created_by: text("created_by").notNull().default('ai_coach'), // 'ai_coach', 'user', 'system' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_user_intel_notes_user_id on ${table} (user_id)`, idxNoteType: sql`create index if not exists idx_user_intel_notes_note_type on ${table} (note_type)`, idxMarketSlug: sql`create index if not exists idx_user_intel_notes_market_slug on ${table} (market_slug)`, idxActive: sql`create index if not exists idx_user_intel_notes_active on ${table} (is_active)`, idxUserActive: sql`create index if not exists idx_user_intel_notes_user_active on ${table} (user_id, is_active, importance)`, })); // ═══════════════════════════════════════════════════════════════════════════ // AI COACH TABLES: Conversation history and system observations // ═══════════════════════════════════════════════════════════════════════════ Coach Conversations Table Stores complete AI Coach conversation history for user-level memory. Enables full thread continuity across sessions, app updates, and tab switches. Features: - Links to user_id for persistent cross-session memory - Optional snapshot_id for context at time of conversation - Stores both user messages and coach responses - Thread grouping via conversation_id - Supports message editing/regeneration tracking // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve conversation history export const coach_conversations = pgTable("coach_conversations", { id: uuid("id").primaryKey().defaultRandom(), // User identification (required for user-level memory) user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // Context at time of conversation (optional - some messages may be context-free) snapshot_id: uuid("snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Market context - ties conversation to a specific market for cross-driver learning market_slug: text("market_slug"), // e.g., "dallas-tx", "los-angeles-ca" - derived from snapshot // Conversation threading (groups messages in a single conversation) conversation_id: uuid("conversation_id").notNull(), // Groups related messages together parent_message_id: uuid("parent_message_id"), // For reply threading (optional) // Message content role: text("role").notNull(), // 'user' | 'assistant' | 'system' content: text("content").notNull(), // The actual message content content_type: text("content_type").default('text'), // 'text' | 'image' | 'file' // Metadata for learning topic_tags: jsonb("topic_tags").default(sql`'[]'`), // AI-classified topics: ['staging', 'surge', 'earnings'] extracted_tips: jsonb("extracted_tips").default(sql`'[]'`), // Tips extracted from this exchange sentiment: text("sentiment"), // 'positive' | 'negative' | 'neutral' - user satisfaction // Context preserved for replay location_context: jsonb("location_context"), // { city, state, lat, lng } at time of message time_context: jsonb("time_context"), // { dow, hour, day_part, timezone } at time of message // Token usage (for cost tracking) tokens_in: integer("tokens_in"), tokens_out: integer("tokens_out"), model_used: text("model_used"), // 'claude-opus-4.5', 'gpt-5.2', etc. // Status is_edited: boolean("is_edited").default(false), // Was this message edited? is_regenerated: boolean("is_regenerated").default(false), // Was the response regenerated? is_starred: boolean("is_starred").default(false), // User starred for reference // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_coach_conversations_user_id on ${table} (user_id)`, idxConversationId: sql`create index if not exists idx_coach_conversations_conversation_id on ${table} (conversation_id)`, idxSnapshotId: sql`create index if not exists idx_coach_conversations_snapshot_id on ${table} (snapshot_id)`, idxCreatedAt: sql`create index if not exists idx_coach_conversations_created_at on ${table} (created_at desc)`, idxUserConversation: sql`create index if not exists idx_coach_conversations_user_conv on ${table} (user_id, conversation_id, created_at)`, // GIN index for topic_tags search idxTopicTags: sql`create index if not exists idx_coach_conversations_topic_tags on ${table} using gin (topic_tags)`, // Market-based queries for cross-driver learning idxMarketSlug: sql`create index if not exists idx_coach_conversations_market_slug on ${table} (market_slug)`, })); Coach System Notes Table AI Coach observations about potential system enhancements, feature requests, and patterns observed during user interactions. Purpose: - Capture "aha moments" from user interactions (e.g., "user wanted screenshot analysis") - Log feature suggestions derived from real usage patterns - Track pain points and common frustrations - Document workarounds that could become features export const coach_system_notes = pgTable("coach_system_notes", { id: uuid("id").primaryKey().defaultRandom(), // Note classification note_type: text("note_type").notNull(), // 'feature_request' | 'pain_point' | 'workaround' | 'aha_moment' | 'bug_report' | 'integration_idea' category: text("category").notNull(), // 'ui' | 'strategy' | 'briefing' | 'venues' | 'coach' | 'map' | 'earnings' | 'general' priority: integer("priority").default(50), // 1-100, higher = more urgent/valuable // Content title: text("title").notNull(), // Short descriptive title description: text("description").notNull(), // Full description of the observation user_quote: text("user_quote"), // Direct quote from user that triggered this note // Context triggering_user_id: uuid("triggering_user_id").references(() => users.user_id, { onDelete: 'set null' }), triggering_conversation_id: uuid("triggering_conversation_id"), // Link to conversation that triggered this triggering_snapshot_id: uuid("triggering_snapshot_id").references(() => snapshots.snapshot_id, { onDelete: 'set null' }), // Usage patterns occurrence_count: integer("occurrence_count").default(1), // How many users/times this has come up affected_users: jsonb("affected_users").default(sql`'[]'`), // Array of user_ids who mentioned this // Market/location context (some notes are market-specific) market_slug: text("market_slug"), is_market_specific: boolean("is_market_specific").default(false), // Status tracking status: text("status").default('new'), // 'new' | 'reviewed' | 'planned' | 'implemented' | 'wont_fix' reviewed_at: timestamp("reviewed_at", { withTimezone: true }), reviewed_by: text("reviewed_by"), implementation_notes: text("implementation_notes"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxNoteType: sql`create index if not exists idx_coach_system_notes_note_type on ${table} (note_type)`, idxCategory: sql`create index if not exists idx_coach_system_notes_category on ${table} (category)`, idxStatus: sql`create index if not exists idx_coach_system_notes_status on ${table} (status)`, idxPriority: sql`create index if not exists idx_coach_system_notes_priority on ${table} (priority desc)`, idxCreatedAt: sql`create index if not exists idx_coach_system_notes_created_at on ${table} (created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // OMNI-PRESENCE / SIRI INTERCEPTOR (2026-01-08) // Level 4 Architecture: Headless client integration for external data ingestion. // Allows iOS Shortcuts, Android automations, etc. to push data without auth. // ═══════════════════════════════════════════════════════════════════════════ Intercepted Signals Table (Level 4: Omni-Presence) Stores ride offers intercepted from external sources (iOS Siri Shortcut, etc.) for AI-powered ACCEPT/REJECT decisions. CRITICAL: user_id is intentionally NOT a Foreign Key reference! This is a "headless" ingestion table - Siri Shortcuts run without authenticated user sessions. We rely on device_id for tracking instead. Data Flow: iOS Shortcut → OCR extracts text → POST /api/hooks/analyze-offer → Parse price/miles/time → AI decision → INSERT intercepted_signals → SSE push to SignalTerminal UI (if app is open) Security: Endpoint uses API key or device registration, not JWT auth. export const intercepted_signals = pgTable("intercepted_signals", { id: uuid("id").primaryKey().defaultRandom(), // Device identification (PRIMARY identifier for headless clients) device_id: varchar("device_id", { length: 255 }).notNull(), // User association (OPTIONAL - NO FK constraint!) // Nullable because Siri Shortcuts run without authenticated sessions. // Can be linked later if user logs in on same device. user_id: uuid("user_id"), // Intentionally NO .references() - headless ingestion // Raw input from OCR raw_text: text("raw_text").notNull(), // Parsed offer data // Schema: { price, miles, time, pickup, dropoff, platform, surge, per_mile } parsed_data: jsonb("parsed_data"), // AI decision decision: text("decision").notNull(), // 'ACCEPT' | 'REJECT' decision_reasoning: text("decision_reasoning"), // AI explanation confidence_score: doublePrecision("confidence_score"), // 0.0 - 1.0 // User override (if driver disagreed with AI) user_override: text("user_override"), // null | 'ACCEPT' | 'REJECT' // Source tracking source: varchar("source", { length: 50 }).notNull().default('siri_shortcut'), // 'siri_shortcut' | 'android_automation' | 'manual' // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxDeviceId: sql`create index if not exists idx_intercepted_signals_device_id on ${table} (device_id)`, idxUserId: sql`create index if not exists idx_intercepted_signals_user_id on ${table} (user_id) where user_id is not null`, idxCreatedAt: sql`create index if not exists idx_intercepted_signals_created on ${table} (device_id, created_at desc)`, })); // ═══════════════════════════════════════════════════════════════════════════ // DISPATCH PRIMITIVES (2026-01-06) // Schema additions for "Where do I go to make $500 today and still get home?" // These tables enable goal-aware, safety-bounded dispatch recommendations. // ═══════════════════════════════════════════════════════════════════════════ Driver Goals Table (P2-A) Tracks earning goals, trip targets, and time constraints. Enables queries like "I want to make $500 by 6pm". export const driver_goals = pgTable("driver_goals", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Goal definition goal_type: text("goal_type").notNull(), // 'earnings' | 'trips' | 'hours' | 'custom' target_amount: doublePrecision("target_amount"), // e.g., 500 for $500, or 10 for 10 trips target_unit: text("target_unit").default('dollars'), // 'dollars' | 'trips' | 'hours' // Time constraints deadline: timestamp("deadline", { withTimezone: true }), // When goal must be achieved by min_hourly_rate: doublePrecision("min_hourly_rate"), // e.g., 35.00 for $35/hr minimum // Priority urgency: text("urgency").default('normal'), // 'low' | 'normal' | 'high' | 'critical' // Status is_active: boolean("is_active").default(true), progress_amount: doublePrecision("progress_amount").default(0), // Current progress completed_at: timestamp("completed_at", { withTimezone: true }), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_goals_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_driver_goals_active on ${table} (user_id, is_active) where is_active = true`, })); Driver Tasks Table (P2-B) Hard stops and time constraints (car wash, pickup kids, appointments). Enables "return-home plan" that respects non-driving obligations. export const driver_tasks = pgTable("driver_tasks", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Task definition title: text("title").notNull(), // e.g., "Car wash appointment" description: text("description"), // Time constraints due_at: timestamp("due_at", { withTimezone: true }), // When task must be done by duration_minutes: integer("duration_minutes"), // How long task takes // Location (optional - some tasks are location-bound) location: text("location"), // Address or place description place_id: text("place_id"), // Google Place ID if available lat: doublePrecision("lat"), lng: doublePrecision("lng"), // Priority is_hard_stop: boolean("is_hard_stop").default(false), // Must stop driving for this priority: integer("priority").default(50), // 1-100 // Status is_complete: boolean("is_complete").default(false), completed_at: timestamp("completed_at", { withTimezone: true }), // Recurrence (optional) recurrence: text("recurrence"), // 'daily' | 'weekly' | 'weekdays' | null // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_driver_tasks_user_id on ${table} (user_id)`, idxDueAt: sql`create index if not exists idx_driver_tasks_due_at on ${table} (user_id, due_at) where is_complete = false`, idxHardStop: sql`create index if not exists idx_driver_tasks_hard_stop on ${table} (user_id, due_at) where is_hard_stop = true and is_complete = false`, })); Safe Zones Table (P2-C) Geofence definitions for safety boundaries. Enables "stay inside safe boundary unless goal demands otherwise". export const safe_zones = pgTable("safe_zones", { id: uuid("id").primaryKey().defaultRandom(), // Owner user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'cascade' }), // Zone identity zone_name: text("zone_name").notNull(), // e.g., "Home area", "Downtown avoid" zone_type: text("zone_type").notNull(), // 'safe' | 'avoid' | 'prefer' // Geometry (one of these should be set) geometry: text("geometry"), // GeoJSON polygon center_lat: doublePrecision("center_lat"), center_lng: doublePrecision("center_lng"), radius_miles: doublePrecision("radius_miles"), // Circular zone radius neighborhoods: text("neighborhoods"), // Comma-separated neighborhood names (alternative to geometry) // Risk assessment risk_level: integer("risk_level"), // 1-5 (1=safest, 5=most risky) risk_notes: text("risk_notes"), // Why this zone has certain risk level // Usage flags is_active: boolean("is_active").default(true), applies_at_night: boolean("applies_at_night").default(true), // Apply after 9pm applies_at_day: boolean("applies_at_day").default(true), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_safe_zones_user_id on ${table} (user_id)`, idxActive: sql`create index if not exists idx_safe_zones_active on ${table} (user_id, is_active) where is_active = true`, idxType: sql`create index if not exists idx_safe_zones_type on ${table} (user_id, zone_type)`, })); Staging Saturation Tracker (P2-D) Tracks staging location suggestions to prevent overcrowding. When many drivers ask for recommendations, we diversify suggestions to avoid sending everyone to the same hotspot. Uses H3 cells (resolution 8 = ~0.5km) for location grouping. export const staging_saturation = pgTable("staging_saturation", { id: uuid("id").primaryKey().defaultRandom(), // Location identification h3_cell: text("h3_cell").notNull(), // H3 index at resolution 8 venue_name: text("venue_name"), // Optional: specific venue name // Time window (suggestions aggregated per hour) window_start: timestamp("window_start", { withTimezone: true }).notNull(), window_end: timestamp("window_end", { withTimezone: true }).notNull(), // Saturation metrics suggestion_count: integer("suggestion_count").notNull().default(0), // How many times suggested active_drivers: integer("active_drivers").default(0), // Estimated drivers currently heading there // Market context market_slug: text("market_slug"), // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), updated_at: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxH3Window: sql`create unique index if not exists idx_staging_saturation_h3_window on ${table} (h3_cell, window_start)`, idxMarketWindow: sql`create index if not exists idx_staging_saturation_market on ${table} (market_slug, window_start)`, idxSuggestionCount: sql`create index if not exists idx_staging_saturation_count on ${table} (suggestion_count desc)`, })); News Deactivations Table Tracks deactivated news items from briefings.news (JSONB). Allows AI Coach or users to mark news stories as inactive with reasoning. Reasons are free-form - we'll learn common patterns as users interact. Examples discovered so far: - "Article is from a year ago" - "Already resolved" - User preference Why separate table vs modifying briefings.news? - briefings.news is per-snapshot, but deactivations are per-user - A user deactivating an old carjacking story affects only their view - Other users may still want to see the same story // 2026-01-05: Changed onDelete from 'cascade' to 'restrict' - preserve user preferences export const news_deactivations = pgTable("news_deactivations", { id: uuid("id").primaryKey().defaultRandom(), // User who deactivated this news item user_id: uuid("user_id").notNull().references(() => users.user_id, { onDelete: 'restrict' }), // News item identification (matches items in briefings.news JSONB) news_hash: text("news_hash").notNull(), // MD5 of normalized(title + source + date) news_title: text("news_title").notNull(), // Original title for reference news_source: text("news_source"), // Source URL or name // Deactivation details - free-form, we'll learn patterns as we go reason: text("reason").notNull(), // Free-form reason from user or AI Coach // Who initiated the deactivation deactivated_by: text("deactivated_by").notNull().default('user'), // 'user' | 'ai_coach' // Scope scope: text("scope").default('user'), // 'user' (just this user) | 'snapshot' (just this context) // Timestamps created_at: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(), }, (table) => ({ idxUserId: sql`create index if not exists idx_news_deactivations_user_id on ${table} (user_id)`, idxNewsHash: sql`create index if not exists idx_news_deactivations_news_hash on ${table} (news_hash)`, // Unique constraint: one deactivation per user per news item uniqueUserNews: sql`create unique index if not exists idx_news_deactivations_unique on ${table} (user_id, news_hash)`, })); Zone Intelligence Table Crowd-sourced, market-specific zone intelligence gathered from driver conversations. Unlike market_intelligence (research-backed), this is real-world intel from actual drivers. Zone Types: - dead_zone: Areas with little to no ride demand - danger_zone: Areas drivers report as unsafe/sketchy - honey_hole: Consistently profitable spots - surge_trap: Areas with fake/unprofitable surge - staging_spot: Good waiting/staging locations - event_zone: Temporary high-demand areas (concerts, games) Cross-Driver Learning: - As multiple drivers report similar zones, confidence increases - Market-specific (zone in Dallas doesn't affect LA) - Time-aware (dead zones may only apply at certain hours)

**Export:** `zone_intelligence`

| Column | Type | Nullable | Default | References |
|--------|------|----------|---------|------------|
| `id` (PK) | UUID | YES | - | - |
| `market_slug` | TEXT | NO | - | - |
| `zone_type` | TEXT | NO | - | - |
| `zone_name` | TEXT | NO | - | - |
| `zone_description` | TEXT | YES | - | - |
| `lat` | DOUBLE PRECISION | YES | - | - |
| `lng` | DOUBLE PRECISION | YES | - | - |
| `radius_miles` | DOUBLE PRECISION | YES | 0.5 | - |
| `address_hint` | TEXT | YES | - | - |
| `time_constraints` | JSONB | YES | sql`'{}'` | - |
| `is_time_specific` | BOOLEAN | YES | false | - |
| `reports_count` | INTEGER | YES | 1 | - |
| `confidence_score` | INTEGER | YES | 50 | - |
| `contributing_users` | JSONB | YES | sql`'[]'` | - |
| `source_conversations` | JSONB | YES | sql`'[]'` | - |
| `last_reason` | TEXT | YES | - | - |
| `last_reported_by` | UUID | YES | - | - |

---

## Standards

This schema follows the standards defined in `docs/architecture/standards.md`:

- **Naming:** snake_case for all tables and columns
- **Foreign Keys:** `<entity>_id` pattern
- **Timestamps:** `*_at` suffix with TIMESTAMPTZ in UTC
- **ISO Codes:** `country_code` (ISO 3166-1), `timezone` (IANA)

## Regeneration

To regenerate this file after schema changes:

```bash
node scripts/generate-schema-docs.js
```

To verify no manual edits (CI check):

```bash
node scripts/generate-schema-docs.js && git diff --exit-code docs/DATABASE_SCHEMA.md
```
