#!/usr/bin/env node
/**
 * Schema Documentation Generator
 *
 * Generates docs/DATABASE_SCHEMA.md from shared/schema.js
 * This is the SINGLE SOURCE OF TRUTH for database documentation.
 *
 * Usage:
 *   node scripts/generate-schema-docs.js
 *
 * CI Integration:
 *   node scripts/generate-schema-docs.js && git diff --exit-code docs/DATABASE_SCHEMA.md
 *   (Fails if manual edits were made)
 *
 * @see docs/architecture/standards.md
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, '..');
const SCHEMA_PATH = path.join(ROOT, 'shared/schema.js');
const OUTPUT_PATH = path.join(ROOT, 'docs/DATABASE_SCHEMA.md');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SCHEMA PARSER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function parseSchema(content) {
  const tables = [];

  // Match pgTable definitions
  const tablePattern = /export\s+const\s+(\w+)\s*=\s*pgTable\s*\(\s*["'](\w+)["']\s*,\s*\{([^}]+(?:\{[^}]*\}[^}]*)*)\}\s*\)/gs;

  let match;
  while ((match = tablePattern.exec(content)) !== null) {
    const [, exportName, tableName, columnsBlock] = match;

    const columns = parseColumns(columnsBlock);

    // Extract comment block before the table
    const beforeTable = content.substring(0, match.index);
    const commentMatch = beforeTable.match(/\/\*\*[\s\S]*?\*\/\s*$/);
    const comment = commentMatch ? extractComment(commentMatch[0]) : null;

    tables.push({
      exportName,
      tableName,
      columns,
      comment,
    });
  }

  return tables;
}

function parseColumns(block) {
  const columns = [];

  // Match column definitions
  const columnPattern = /(\w+)\s*:\s*(text|uuid|timestamp|integer|boolean|doublePrecision|varchar|jsonb|serial)\s*\(\s*["']?([^"'\)]+)["']?\s*\)([^,\n]*)/g;

  let match;
  while ((match = columnPattern.exec(block)) !== null) {
    const [fullMatch, fieldName, drizzleType, dbColumnName] = match;
    const modifiers = match[4] || '';

    columns.push({
      fieldName,
      dbColumnName: dbColumnName || fieldName,
      type: mapType(drizzleType),
      nullable: !modifiers.includes('.notNull()'),
      primaryKey: modifiers.includes('.primaryKey()'),
      defaultValue: extractDefault(modifiers),
      references: extractReference(modifiers),
    });
  }

  return columns;
}

function mapType(drizzleType) {
  const typeMap = {
    text: 'TEXT',
    uuid: 'UUID',
    timestamp: 'TIMESTAMPTZ',
    integer: 'INTEGER',
    boolean: 'BOOLEAN',
    doublePrecision: 'DOUBLE PRECISION',
    varchar: 'VARCHAR',
    jsonb: 'JSONB',
    serial: 'SERIAL',
  };
  return typeMap[drizzleType] || drizzleType.toUpperCase();
}

function extractDefault(modifiers) {
  const match = modifiers.match(/\.default\s*\(\s*(.+?)\s*\)/);
  if (match) {
    if (match[1].includes('defaultRandom')) return 'uuid_generate_v4()';
    if (match[1].includes('defaultNow')) return 'NOW()';
    return match[1];
  }
  return null;
}

function extractReference(modifiers) {
  const match = modifiers.match(/\.references\s*\(\s*\(\)\s*=>\s*(\w+)\.(\w+)\s*\)/);
  if (match) {
    return { table: match[1], column: match[2] };
  }
  return null;
}

function extractComment(commentBlock) {
  return commentBlock
    .replace(/\/\*\*|\*\//g, '')
    .split('\n')
    .map(line => line.replace(/^\s*\*\s?/, '').trim())
    .filter(line => line.length > 0)
    .join(' ');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MARKDOWN GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateMarkdown(tables) {
  const timestamp = new Date().toISOString();

  let md = `# Database Schema Reference

> **AUTO-GENERATED FILE** - Do not edit manually!
>
> Generated by \`scripts/generate-schema-docs.js\` from \`shared/schema.js\`
>
> Last generated: ${timestamp}

---

## Quick Reference

| Table | Export Name | Columns | Description |
|-------|-------------|---------|-------------|
`;

  for (const table of tables) {
    const desc = table.comment ? table.comment.substring(0, 50) + '...' : '-';
    md += `| \`${table.tableName}\` | \`${table.exportName}\` | ${table.columns.length} | ${desc} |\n`;
  }

  md += '\n---\n\n';

  // Detailed table docs
  for (const table of tables) {
    md += `## \`${table.tableName}\`\n\n`;

    if (table.comment) {
      md += `${table.comment}\n\n`;
    }

    md += `**Export:** \`${table.exportName}\`\n\n`;

    md += '| Column | Type | Nullable | Default | References |\n';
    md += '|--------|------|----------|---------|------------|\n';

    for (const col of table.columns) {
      const pk = col.primaryKey ? ' (PK)' : '';
      const ref = col.references ? `${col.references.table}.${col.references.column}` : '-';
      const def = col.defaultValue || '-';
      const nullable = col.nullable ? 'YES' : 'NO';

      md += `| \`${col.dbColumnName}\`${pk} | ${col.type} | ${nullable} | ${def} | ${ref} |\n`;
    }

    md += '\n---\n\n';
  }

  // Footer
  md += `## Standards

This schema follows the standards defined in \`docs/architecture/standards.md\`:

- **Naming:** snake_case for all tables and columns
- **Foreign Keys:** \`<entity>_id\` pattern
- **Timestamps:** \`*_at\` suffix with TIMESTAMPTZ in UTC
- **ISO Codes:** \`country_code\` (ISO 3166-1), \`timezone\` (IANA)

## Regeneration

To regenerate this file after schema changes:

\`\`\`bash
node scripts/generate-schema-docs.js
\`\`\`

To verify no manual edits (CI check):

\`\`\`bash
node scripts/generate-schema-docs.js && git diff --exit-code docs/DATABASE_SCHEMA.md
\`\`\`
`;

  return md;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function main() {
  console.log('ğŸ“š Schema Documentation Generator\n');

  // Read schema file
  if (!fs.existsSync(SCHEMA_PATH)) {
    console.error(`âŒ Schema file not found: ${SCHEMA_PATH}`);
    process.exit(1);
  }

  console.log(`Reading: ${path.relative(ROOT, SCHEMA_PATH)}`);
  const schemaContent = fs.readFileSync(SCHEMA_PATH, 'utf8');

  // Parse schema
  console.log('Parsing schema definitions...');
  const tables = parseSchema(schemaContent);
  console.log(`Found ${tables.length} tables\n`);

  // Generate markdown
  console.log('Generating documentation...');
  const markdown = generateMarkdown(tables);

  // Write output
  console.log(`Writing: ${path.relative(ROOT, OUTPUT_PATH)}`);
  fs.writeFileSync(OUTPUT_PATH, markdown);

  console.log('\nâœ… Schema documentation generated successfully!');
  console.log('\nTo verify no drift in CI:');
  console.log('  git diff --exit-code docs/DATABASE_SCHEMA.md');
}

main();
